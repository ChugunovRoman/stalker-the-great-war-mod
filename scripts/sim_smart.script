defense_timers = {}
defense_next_update = {}

attack_timers = {}
attack_next_update = {}

mutant_timers = {}
mutant_next_update = {}

respawn_timers = {}
respawn_next_update = {}

unique_check_timers = {}
unique_check_next_update = {}

smart_owners = {}
hide_sim = false

asma = {}

sl = 0
smx = 0

----------------------------- äèàëîãè

local saved_dialog
function add_dialog(p_id, id, phrase_id, cond, act)
  if not (saved_dialog) then
    return
  end

  local phrase = saved_dialog:AddPhrase(phrase_id, tostring(id), tostring(p_id), -10000)
  if not (phrase) then
    return
  end

  --printf("phrase_id = %s",phrase_id)

  local phrase_script = phrase:GetPhraseScript()
  if (cond) then
    if (type(cond) == "table") then
      for key, value in pairs(cond) do
        if (alun_utils.findfunction(value, _G)) then
          --table.insert(cond_list,value)
          phrase_script:AddPrecondition(value)
        else
          printf("dialog_manager:Error: No such function exists '%s'", value)
        end
      end
    else
      if (alun_utils.findfunction(cond, _G)) then
        --table.insert(cond_list,value)
        phrase_script:AddPrecondition(cond)
      else
        printf("dialog_manager:Error: No such function exists '%s'", cond)
      end
    end
  end

  if (act) then
    if (type(act) == "table") then
      for key, value in pairs(act) do
        if (alun_utils.findfunction(value, _G)) then
          phrase_script:AddAction(value)
        else
          printf("dialog_manager:Error: No such function exists '%s'", value)
        end
      end
    else
      if (alun_utils.findfunction(act, _G)) then
        phrase_script:AddAction(act)
      else
        printf("dialog_manager:Error: No such function exists '%s'", act)
      end
    end
  end
  return phrase_script
end

function add_script_dialog(p_id, id, phrase_id, cond, act)
  local d = add_dialog(p_id, id, phrase_id, cond, act)
  if (d) then
    d:SetScriptText(phrase_id)
  end
end

function set_actor_dialogs(npc, ini, name, dialog_section)
  if dialog_section == nil then
    return
  end
  local actor_dialogs_string = ini:r_string_ex(dialog_section, "id") or ""
  if actor_dialogs_string ~= nil then
    db.storage[npc:id()].actor_dialogs = parse_names(actor_dialogs_string)
  end

  local actor_disable = ini:r_string_ex(dialog_section, "disable") or ""
  if actor_disable ~= nil then
    db.storage[npc:id()].actor_disable = parse_names(actor_disable)
  end
end

-- áàçà/òî÷êà [èìÿ ] [ãðóïïèðîâêà] - àòàêà / ïîäìîãà

function alltext(actor, npc, sele)
  local tupe = ""
  local tupe2 = ""
  local npc = dialogs.who_is_npc(actor, npc)
  local ssmart = asma[sl + sele]
  local script_to_text_smart = sim_script_to_text.smart_names[ssmart:name()] or ssmart:name()
  local faction = character_community(npc)
  local faction2 = ssmart.owning_faction

  if (faction2 == "none" or faction2 == nil) then
    faction2 = "[ÏÓÑÒÎ]"
  end

  if (faction2 == "army") then
    faction2 = "[ÂÎÅÍÍÛÅ]"
  end

  if (faction2 == "bandit") then
    faction2 = "[ÁÀÍÄÈÒÛ]"
  end

  if (faction2 == "csky") then
    faction2 = "[×ÈÑÒÎÅ ÍÅÁÎ]"
  end

  if (faction2 == "dolg") then
    faction2 = "[ÄÎËÃ]"
  end

  if (faction2 == "ecolog") then
    faction2 = "[Ó×¨ÍÛÅ]"
  end

  if (faction2 == "freedom") then
    faction2 = "[ÑÂÎÁÎÄÀ]"
  end

  if (faction2 == "killer") then
    faction2 = "[ÍÀ¨ÌÍÈÊÈ]"
  end

  if (faction2 == "monolith") then
    faction2 = "[ÌÎÍÎËÈÒ]"
  end

  if (faction2 == "stalker") then
    faction2 = "[ÎÄÈÍÎ×ÊÈ]"
  end

  if (faction2 == "zombied") then
    faction2 = "[ÇÎÌÁÈÐÎÂÀÍÍÛÅ]"
  end

  if (faction2 == "isg") then
    faction2 = "[ÈÈÃ]"
  end

  if (faction2 == "darkstalker") then
    faction2 = "[ÒÅÌÍÛÅ ÑÒÀËÊÅÐÛ]"
  end

  if (faction2 == "renegate") then
    faction2 = "[ÐÅÍÅÃÀÒÛ]"
  end

  if (faction2 == "mstitel") then
    faction2 = "[ÌÑÒÈÒÅËÈ]"
  end

  if (faction2 == "slizni") then
    faction2 = "[×ÅÐÍÛÅ ÑËÈÇÍÈ]"
  end

  if (faction2 == "velhan") then
    faction2 = "[ÂÅËÈÊÈÅ ÕÀÍÛ]"
  end

  if (faction2 == "fantom") then
    faction2 = "[ÔÀÍÒÎÌÛ]"
  end

  if (faction2 == "veter") then
    faction2 = "[ÂÅÒÅÐ]"
  end

  if (faction2 == "osoznanie") then
    faction2 = "[Î-ÑÎÇÍÀÍÈÅ]"
  end

  if (faction2 == "alfa") then
    faction2 = "[ÎÒÐßÄ ÀËÜÔÀ]"
  end

  if (faction2 == "ansf") then
    faction2 = "[ANS-F11]"
  end

  if (faction2 == "adinkvizicia") then
    faction2 = "[ÀÄÑÊÀß ÈÍÊÂÈÇÈÖÈß]"
  end

  if (faction2 == "zakat") then
    faction2 = "[ÃÐÓÏÏÈÐÎÂÊÀ ÇÀÊÀÒ]"
  end

  if (faction2 == "voenstal") then
    faction2 = "[ÂÎÅÍÍÛÅ ÑÒÀËÊÅÐÛ]"
  end

  if (faction2 == "mirotvorec") then
    faction2 = "[ÌÈÐÎÒÂÎÐÖÛ]"
  end

  if (faction2 == "ryskuspecnaz") then
    faction2 = "[ÐÓÑÑÊÈÉ ÑÏÅÖÍÀÇ]"
  end

  if (faction2 == "sby") then
    faction2 = "[ÑÁÓ]"
  end

  if (faction2 == "terrorust") then
    faction2 = "[ÒÅÐÐÎÐÈÑÒÛ]"
  end

  if (faction2 == "posleduden") then
    faction2 = "[ÏÎÑËÅÄÍÈÉ ÄÅÍÜ]"
  end

  if (faction2 == "greh") then
    faction2 = "[ÃÐÅÕ]"
  end

	-- TODO: Ïîìåìó-òî âñåãäà false äàæå åñëè ñòðîêè ðàâíû
  if faction == faction2 then
    tupe2 = "ïîäìîãà"
  else
    tupe2 = "àòàêà"
	end
	
	printf('sim_smart.alltext: faction == faction2: '..faction == faction2.." | '"..faction.."' == '"..faction2.."' | "..tupe2)

  if (ssmart and ssmart.props) then
    if (ssmart.props.base > 0) then
      tupe = "Áàçà"
    elseif (ssmart.props.resource > 0) then
      tupe = "Ðåñóðñíàÿ òî÷êà"
    elseif (ssmart.props.territory > 0) then
      tupe = "Òåððèòîðèÿ"
    elseif (ssmart.props.lair > 0) then
      tupe = "Ëîãîâî"
    end
  end

  local text = tupe .. " " .. script_to_text_smart .. " " .. faction2 .. " " .. tupe2
  return text
end

function txt1(a, b)
  local sele = 1
  return alltext(a, b, sele)
end

function txt2(a, b)
  local sele = 2

  return alltext(a, b, sele)
end
function txt3(a, b)
  local sele = 3

  return alltext(a, b, sele)
end
function txt4(a, b)
  local sele = 4

  return alltext(a, b, sele)
end
function txt5(a, b)
  local sele = 5

  return alltext(a, b, sele)
end

function sl1(a, b)
  local sele = 1

  spawn_attack(a, b, sele)
end
function sl2(a, b)
  local sele = 2

  spawn_attack(a, b, sele)
end
function sl3(a, b)
  local sele = 3

  spawn_attack(a, b, sele)
end
function sl4(a, b)
  local sele = 4

  spawn_attack(a, b, sele)
end
function sl5(a, b)
  local sele = 5

  spawn_attack(a, b, sele)
end

function slm1(a, b)
  local sele = 1

  send_squad_on_target(a, b, sele)
end
function slm2(a, b)
  local sele = 2

  send_squad_on_target(a, b, sele)
end
function slm3(a, b)
  local sele = 3

  send_squad_on_target(a, b, sele)
end
function slm4(a, b)
  local sele = 4

  send_squad_on_target(a, b, sele)
end
function slm5(a, b)
  local sele = 5

  send_squad_on_target(a, b, sele)
end

function ch(actor, npc, sele)
  local ssmart = asma[sl + sele]
  if (ssmart) then
    return true
  end

  return false
end

function ch1(a, b)
  local sele = 1
  return ch(a, b, sele)
end

function ch2(a, b)
  local sele = 2

  return ch(a, b, sele)
end
function ch3(a, b)
  local sele = 3

  return ch(a, b, sele)
end
function ch4(a, b)
  local sele = 4

  return ch(a, b, sele)
end
function ch5(a, b)
  local sele = 5

  return ch(a, b, sele)
end

function chsect(a, npc)
	local npc = dialogs.who_is_npc(a, npc)

	if (npc) then
		local level_id = game_graph():vertex(alife():actor().m_game_vertex_id):level_id()

		if (level_id) then
      local level_info = sim_levels.level_information[level_id]
      local num = 0

      asma = {}
      if (level_info) then
        for i, sm in pairs(level_info.smarts) do
          local other = sm and alife():object(sm)
          if (other and other.props) and
            (other.props.base > 0 or other.props.resource > 0 or other.props.territory > 0 or other.props.lair > 0)
					then
            num = num + 1

            asma[#asma + 1] = other

            printf("### EOC: -- s -- " .. other:name() .. " - ### " .. asma[num]:name())
          end
        end
        if num > 0 then
          sl = 0
          smx = num
          printf("### EOC: -- s -- " .. smx .. " - ### " .. num)
          return true
        end
      end
    end
  end
  return false
end

function prefx(a, npc)
  sl = sl - 5
  if (sl < 0) then
    sl = 0
  end
end

function nextx(a, b)
  sl = sl + 5
  if (sl > smx) then
    sl = smx - 5
  end
end

function spawn_defense(actor, npc)
  if (db.actor:money() >= 5000) then
    local npc = dialogs.who_is_npc(actor, npc)

    local smart = xr_gulag.get_npc_smart(npc)

    local faction = smart.owning_faction

    local script_to_text_smart = sim_script_to_text.smart_names[smart:name()] or smart:name()

    db.actor:give_money(-5000)
    sim_squad.create_squad(smart, faction, nil, nil, nil, 1)
    db.actor:give_game_news(
      ("Çàùèòíûé îòðÿä"),
      ("Ñïàñèáî çà 5 000ð, ìû áóäåì äåðæàòü ïîçèöèþ " .. script_to_text_smart),
      sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
      0,
      15000
    )
  else
    db.actor:give_game_news(
      ("Ôèíàíñîâûå îïåðàöèè"),
      ("Íåäîñòàòî÷íî äåíåã, íóæíî 5 000ð "),
      sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
      0,
      15000
    )
  end
end

function spawn_attack(actor, npc, sele)
  if (db.actor:money() >= 5000) then
    local npc = dialogs.who_is_npc(actor, npc)

    local smart = xr_gulag.get_npc_smart(npc)

    local target = asma[sl + sele]

    local sname = sim_script_to_text.smart_names[smart:name()] or smart:name()

    local script_to_text_smart = sim_script_to_text.smart_names[target:name()] or target:name()

    local faction = smart.owning_faction

    if (target) then
      local need_spawn = npc_count_passive(target, target.owning_faction)

      if need_spawn > 10 then
        need_spawn = 10
      end

      local fi = sim_factions.faction_information[smart.owning_faction]

      if (fi) then
        local allowed_for_spawn = fi.faction_active_npc_limit - fi.active_npc

        if need_spawn > allowed_for_spawn then
          need_spawn = allowed_for_spawn
        end
      end
      db.actor:give_money(-5000)
      sim_squad.create_squad(smart, faction, target, nil, need_spawn, 1)
      db.actor:give_game_news(
        ("Àòàêóþùèé îòðÿä"),
        ("Ñïàñèáî çà 5 000ð, ìû âûäâèãàåìñÿ îò " ..
          sname .. " ê " .. script_to_text_smart .. " åñëè åñòü æåëàíèå ïîéäåì ñ íàìè "),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    end
  else
    db.actor:give_game_news(
      ("Ôèíàíñîâûå îïåðàöèè"),
      ("Íåäîñòàòî÷íî äåíåã, íóæíî 5 000ð "),
      sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
      0,
      15000
    )
  end
end

function send_squad_on_target(actor, npc, sele)
	local npc = dialogs.who_is_npc(actor, npc)
	local squad = get_object_squad(npc)
	local target = asma[sl + sele]
	local script_to_text_smart = sim_script_to_text.smart_names[target:name()] or target:name()

	if (target) then
		alun_utils.execute_script_on_squad(npc, axr_companions.remove_from_actor_squad)

		sim_squad.set_target(squad, target.id)

		db.actor:give_game_news(
			("Àòàêóþùèé îòðÿä"),
			("Ìû âûäâèãàåìñÿ ê " .. script_to_text_smart .. "."),
			sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
			0,
			15000
		)
	end
end

function textinfo(a, b)
  local npc = dialogs.who_is_npc(a, b)

  local smart = xr_gulag.get_npc_smart(npc)
  local text = sl .. "-" .. (sl + 5) .. " âñåãî " .. smx

  return text
end

function dlgspwg(dialog)
  saved_dialog = dialog

  add_dialog("", 0, "Íå çíàåøü ñëó÷àéíî êàê ìîæíî ïîìî÷ü ðàçâèòèþ ãðóïïèðîâêè?")

  add_dialog(0, 1, "Íàïðèìåð ìîæíî ñîçäàòü îòðÿä è äàòü åìó çàäàíèå")

  --add_dialog(1,10,"â íà÷àëî",nil,"dialogs_axr_companion.set_companion_to_follow_state")
  add_dialog(1, 2, "Äàâàé íàïðàâèì îòðÿä íà îäíó èç òî÷åê ", "sim_smart.chsect")
  add_dialog(1, 4, "Äàâàé ñîçäàäèì îòðÿä äëÿ çàùèòû òåêóùåé òî÷êè ", "sim_smart.chsect")
  add_dialog(4, 5, "Ëàäíî, ýòî áóäåò ñòîèòü 5 000 ")
  add_dialog(2, 3, "Ëàäíî, ýòî áóäåò ñòîèòü 5 000, âûáåðè êóäà îíè äîëæíû âûäâèíóòñÿ ")

  add_dialog(5, 903, "Õîðîøî âîò 5 000. Ìíå çäåñü íóæíû ðåáÿòà", nil, "sim_smart.spawn_defense")
  add_dialog(5, 904, "ß ïåðåäóìàë ")

  add_script_dialog(3, 900, "sim_smart.textinfo")

  add_script_dialog(3, 9001, "sim_smart.txt1", "sim_smart.ch1", "sim_smart.sl1")
  add_script_dialog(3, 9002, "sim_smart.txt2", "sim_smart.ch2", "sim_smart.sl2")
  add_script_dialog(3, 9003, "sim_smart.txt3", "sim_smart.ch3", "sim_smart.sl3")
  add_script_dialog(3, 9004, "sim_smart.txt4", "sim_smart.ch4", "sim_smart.sl4")
  add_script_dialog(3, 9005, "sim_smart.txt5", "sim_smart.ch5", "sim_smart.sl5")

  add_dialog(3, 901, "-Ïðåäûäóùèå ñåêòîðà", nil, "sim_smart.prefx")
  add_dialog(3, 902, "-Ñëåäóþùèå ñåêòîðà", nil, "sim_smart.nextx")
  add_dialog(901, 3, "Ñìîòðè, âîò ïðåäûäóùèå 5")

  add_dialog(902, 3, "Ñìîòðè, âîò ñëåäóþùèå 5")
  add_dialog(3, 998, "ß ïåðåäóìàë ")

  -- add_dialog(1,10,"ñëåäóùèå",nil,"dialogs_axr_companion.set_companion_to_follow_state")
  ------{{Submenu --> exit}} (900+)
  add_dialog(1, 999, "Çàáóäü")
end

function set_max_population(smart)
  if (smart.props) then
    smart.max_population = 10

    if smart.props.lair > 0 then
      smart.max_population = 8
    elseif smart.props.base > 0 then
      smart.max_population = sim_brain.check_individual_smart_pop(smart)
    end
  end
end

function smart_terrain_on_update(smart)
  local curr_time = game.get_game_time()
  smart.last_respawn_update = curr_time

  if not (smart.level_id) then
    smart.level_id = game_graph():vertex(smart.m_game_vertex_id):level_id()
  end

  if not (smart.first_update) then
    smart.first_update = true

    set_max_population(smart)

    if (smart_owners[smart.id]) then
      smart.owning_faction = smart_owners[smart.id]
    end

    local offset = sim_tables.level_offsets[smart.level_id]
    local p = smart.position

    if (offset) then
      smart.global_position = vector():set(p.x + offset[1], p.y + offset[2], p.z + offset[3])
    end
  end

  check_owner(smart)

  if not (smart.target_smarts) then
    smart.target_smarts = {}
  end

  if not (smart.target_smart_count) then
    smart.target_smart_count = 0
  end

  if not (sim_brain.initialized) then
    return
  end

  local faction = smart.owning_faction
  local dist = alife():actor().position:distance_to_sqr(smart.position)

  if smart.props then
    if dist > 20000 then
      smart_control(smart)
    end
    process_mutants(smart)
    if smart.props.base > 0 then
      set_targets(smart)
      target_manual_capture(smart)
      if dist > 2500 then
        if (faction == "none" and config_fact.respawnfactions) then
          try_to_respawn_faction(smart)
        else
          spawn_defense_squad(smart)
          spawn_attack_squad(smart)
          if faction ~= "zombied" and faction ~= "monster" then
            check_npc(smart)
          end
        end
      end
    elseif smart.props.lair > 0 then
      if faction == "none" and dist > 20000 then
        spawn_mutants(smart)
      end
    else
      if smart.props.base > 0 or smart.props.resource > 0 or smart.props.territory > 0 or smart.props.lair > 0 then
        target_manual_capture(smart)
      end
    end
  end
end

function try_to_respawn_faction(smart)
  if not (respawn_timers[smart.id]) then
    respawn_timers[smart.id] = game.get_game_time()
    respawn_next_update[smart.id] = 200
    return
  elseif (game.get_game_time():diffSec(respawn_timers[smart.id]) > (respawn_next_update[smart.id] * 30)) then
    respawn_timers[smart.id] = game.get_game_time()
    respawn_next_update[smart.id] = 200
  else
    return
  end

  local smart_level = alife():level_name(game_graph():vertex(smart.m_game_vertex_id):level_id())

  for i, faction in pairs(sim_tables.factions) do
    if faction ~= "monster" then
      if
        (sim_factions.faction_information[faction].base_count) and
          sim_factions.faction_information[faction].base_count < 1
       then
        local level_chk = sim_brain.allowed_respawn(smart_level, faction)

        if level_chk == true then
          sim_factions.faction_information[faction].base_count =
            sim_factions.faction_information[faction].base_count + 1
          sim_squad.create_squad(smart, faction, nil, nil, nil, 1)
          break
        end
      end
    end
  end
end

function check_npc(smart)
  if
    not (unique_check_timers[smart.id]) or
      (game.get_game_time():diffSec(unique_check_timers[smart.id]) > (unique_check_next_update[smart.id] * 60))
   then
    unique_check_timers[smart.id] = game.get_game_time()
    unique_check_next_update[smart.id] = sim_factions.faction_information[smart.owning_faction].respawn_defend
  else
    return
  end

  local faction = smart.owning_faction
  local trader = faction .. "_sim_squad_trader"
  local mechanic = faction .. "_sim_squad_mechanic"
  local barmen = faction .. "_sim_squad_barmen"
  local medik = faction .. "_sim_squad_medik"

  local uniques = {}
  uniques.mar_smart_terrain_base = {1, 1, 1, 1}
  uniques.esc_smart_terrain_5_7 = {1, 1, 0, 0}
  uniques.esc_smart_terrain_3_16 = {1, 0, 0, 0}
  uniques.val_smart_terrain_7_3 = {0, 1, 0, 0}
  uniques.val_smart_terrain_7_4 = {1, 0, 0, 0}
  uniques.agr_smart_terrain_1_6 = {1, 1, 0, 0}
  uniques.bar_visitors = {0, 1, 0, 0}
  uniques.bar_dolg_general = {1, 0, 0, 1}
  uniques.mil_smart_terrain_7_7 = {0, 1, 0, 0}
  uniques.mil_smart_terrain_7_10 = {1, 0, 0, 0}
  uniques.cit_killers = {1, 1, 0, 0}
  uniques.pri_monolith = {1, 1, 0, 0}
  uniques.pri_a16 = {1, 1, 0, 0}
  uniques.zat_stalker_base_smart = {1, 1, 1, 1}
  uniques.jup_a6 = {1, 1, 1, 1}
  uniques.gar_smart_terrain_3_5 = {1, 1, 0, 0}
  uniques.ds2_domik_st = {1, 1, 0, 0}
  uniques.mar_smart_terrain_10_5 = {1, 1, 0, 0}
  uniques.jup_b41 = {1, 1, 0, 0}
  uniques.yan_smart_terrain_6_4 = {1, 1, 0, 0}

  if (uniques[smart:name()]) then
    local tbl = uniques[smart:name()]
    local trader_pop = tbl[1]
    local mechanic_pop = tbl[2]
    local barmen_pop = tbl[3]
    local medik_pop = tbl[4]

    local mechanic_in_smart = 0
    local trader_in_smart = 0
    local medik_in_smart = 0
    local barmen_in_smart = 0

    local squads = SIMBOARD.smarts[smart.id].squads

    for i, s in pairs(squads) do
      if string.find(s:name(), "mechanic") or string.find(s:name(), "tech") or string.find(s:name(), "drunk") then
        mechanic_in_smart = mechanic_in_smart + 1
      end

      if string.find(s:name(), "trader") or string.find(s:name(), "petrenko") then
        trader_in_smart = trader_in_smart + 1
      end

      if string.find(s:name(), "barmen") then
        barmen_in_smart = barmen_in_smart + 1
      end

      if string.find(s:name(), "medik") or string.find(s:name(), "medic") or string.find(s:name(), "doctor") then
        medik_in_smart = medik_in_smart + 1
      end
    end

    local smart_limit = npc_count(smart, smart.owning_faction)

    if (smart_limit < smart.max_population) then
      while mechanic_in_smart < mechanic_pop do
        sim_squad.create_squad(smart, faction, nil, mechanic, nil, 1)
        mechanic_in_smart = mechanic_in_smart + 1
        printf("### EOC: -- check_npc 1 -- " .. smart:name() .. " - mechanic ###")
      end

      while trader_in_smart < trader_pop do
        sim_squad.create_squad(smart, faction, nil, trader, nil, 1)
        trader_in_smart = trader_in_smart + 1
        printf("### EOC: -- check_npc 2 -- " .. smart:name() .. " - trader ###")
      end

      while barmen_in_smart < barmen_pop do
        sim_squad.create_squad(smart, faction, nil, barmen, nil, 1)
        barmen_in_smart = barmen_in_smart + 1
        printf("### EOC: -- check_npc 3 -- " .. smart:name() .. " - barmen ###")
      end

      while medik_in_smart < medik_pop do
        sim_squad.create_squad(smart, faction, nil, medik, nil, 1)
        medik_in_smart = medik_in_smart + 1
        printf("### EOC: -- check_npc 4 -- " .. smart:name() .. " - medik ###")
      end
    end
  end
end

function target_manual_capture(smart)
  if not smart.online then
    return
  end
  local tg = time_global()
  if smart.manual_capture ~= nil and tg < smart.manual_capture then
    return
  end
  smart.manual_capture = tg + 5000
  if smart.owning_faction ~= "none" then
    return
  end
  local script_to_text_smart = sim_script_to_text.smart_names[smart:name()] or smart:name()
  local dist = smart.position:distance_to_sqr(alife():actor().position)
  if (dist > 1500 and smart.time_to_capture) then
    smart.time_to_capture = nil
    if smart.props.base > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âû ïðåêðàòèëè çàõâàò áàçû " .. script_to_text_smart),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.resource > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âû ïðåêðàòèëè çàõâàò òî÷êè ðåñóðñîâ " .. script_to_text_smart),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.territory > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âû ïðåêðàòèëè çàõâàò òåððèòîðèè " .. script_to_text_smart),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.lair > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âû ïðåêðàòèëè çàõâàò ëîãîâà " .. script_to_text_smart),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    end
    xr_sound.set_sound_play(db.actor:id(), "pda_tips")
  end
  if (dist > 1500) then
    return
  end
  if not (smart.time_to_capture) then
    smart.time_to_capture = 0
    if smart.props.base > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âû çàõâàòûâàåòå áàçó " .. script_to_text_smart),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.resource > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âû çàõâàòûâàåòå òî÷êó ðåñóðñîâ " .. script_to_text_smart),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.territory > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âû çàõâàòûâàåòå òåððèòîðèþ " .. script_to_text_smart),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.lair > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âû çàõâàòûâàåòå ëîãîâà " .. script_to_text_smart),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    end
    xr_sound.set_sound_play(db.actor:id(), "pda_tips")
  end
  if (smart.time_to_capture < 5) then
    smart.time_to_capture = smart.time_to_capture + 1
    return
  end
  local faction = sim_brain.actor_faction
  sim_squad.create_squad(smart, faction, nil, nil, nil, 1)
  if smart.last_last_owner == faction then
    if smart.props.base > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âîçâðàùåí êîíòðîëü íàä áàçîé " ..
          script_to_text_smart .. ", ñêîðî íà ýòî ìåñòî ïðèáóäóò îòðÿäû âàøåé ãðóïïèðîâêè"),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.resource > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âîçâðàùåí êîíòðîëü íàä òî÷êîé ðåñóðñîâ " ..
          script_to_text_smart .. ", ñêîðî íà ýòî ìåñòî ïðèáóäóò îòðÿäû âàøåé ãðóïïèðîâêè"),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.territory > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âîçâðàùåí êîíòðîëü íàä òåððèòîðèåé " ..
          script_to_text_smart .. ", ñêîðî íà ýòî ìåñòî ïðèáóäóò îòðÿäû âàøåé ãðóïïèðîâêè"),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.lair > 0 then
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Âîçâðàùåí êîíòðîëü íàä ëîãîâûì " ..
          script_to_text_smart .. ", ñêîðî íà ýòî ìåñòî ïðèáóäóò îòðÿäû âàøåé ãðóïïèðîâêè"),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    end
    xr_sound.set_sound_play(db.actor:id(), "pda_tips")
    smart.time_to_capture = nil
  else
    local nagrada = 3000 + math.random(0, 0)

    if smart.props.base > 0 then
      nagrada = 3000 + math.random(0, 0)
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Áàçà " .. script_to_text_smart .. " çàõâà÷åíà, íàãðàäà çà çàõâàò - " .. nagrada .. " ðóá. "),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.resource > 0 then
      nagrada = -1000 + math.random(0, 0)
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Òî÷êà ðåñóðñîâ " .. script_to_text_smart .. " çàõâà÷åíà, íàãðàäà çà çàõâàò - " .. nagrada .. " ðóá. "),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.territory > 0 then
      nagrada = -5000 + math.random(0, 0)
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Òåððèòîðèÿ " .. script_to_text_smart .. " çàõâà÷åíà, íàãðàäà çà çàõâàò - " .. nagrada .. " ðóá. "),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    elseif smart.props.lair > 0 then
      nagrada = -10000 + math.random(0, 0)
      db.actor:give_game_news(
        ("Çàõâàò öåëè"),
        ("Ëîãîâî " .. script_to_text_smart .. " çàõâà÷åíà, íàãðàäà çà çàõâàò - " .. nagrada .. " ðóá. "),
        sim_offline_to_online.getSenderIcon(sim_brain.actor_faction),
        0,
        15000
      )
    end
    xr_sound.set_sound_play(db.actor:id(), "pda_tips")
    db.actor:give_money(nagrada)
    smart.time_to_capture = nil
  end
end

function smart_control(smart)
  local tg = time_global()

  if smart.last_npc_check ~= nil and tg < smart.last_npc_check then
    return
  end

  smart.last_npc_check = tg + 30000

  local squads = SIMBOARD.smarts[smart.id].squads

  for i, squad in pairs(squads) do
    local faction = squad:get_squad_community()

    if (squad.registered_in_simultaion and squad.current_action == 1) then
      local npc_count = npc_count_passive(smart, faction)

      if
        (faction ~= smart.owning_faction and
          not game_relations.is_factions_enemies(faction, smart.owning_faction))
       then
        if (smart.owning_faction ~= "none" and faction ~= "monster") then
          sim_squad.remove_squad(squad)
          printf("### EOC: -- smart_control 1 -- " .. squad:name() .. " - " .. smart:name() .. " ###")
        end
      end

      if
        (npc_count > smart.max_population) and
          (string.find(squad:name(), "veteran") or string.find(squad:name(), "master") or
            string.find(squad:name(), "advanced") or
            string.find(squad:name(), "nachunaushu") or
            string.find(squad:name(), "novnachun") or
            string.find(squad:name(), "novadvan") or
            string.find(squad:name(), "advanvet") or
            string.find(squad:name(), "vetmas") or
            string.find(squad:name(), "rybech") or
            string.find(squad:name(), "novice"))
       then
        local squad_npcs = {}

        if squad.current_action == 1 then
          for k in squad:squad_members() do
            squad_npcs[#squad_npcs + 1] = k
          end

          local k1 = squad_npcs[math.random(#squad_npcs)]

          if (k1) then
            squad:remove_npc(k1.id)
          end

          printf("### EOC: -- smart_control 2 -- " .. squad:name() .. " - " .. smart:name() .. " ###")
        end
      end
    end
  end
end

function set_targets(smart)
  local tg = time_global()

  if smart.set_targets ~= nil and tg < smart.set_targets then
    return
  end

  smart.set_targets = tg + 10000

  local target_smart_count = 0
  for target, v in pairs(smart.target_smarts) do
    local other = alife():object(target)

    if (other and other.owning_faction) then
      if
        (other.owning_faction ~= "none" and
          not game_relations.is_factions_enemies(smart.owning_faction, other.owning_faction))
       then
        smart.target_smarts[other.id] = nil
      else
        target_smart_count = target_smart_count + 1
      end
    end
  end

  if (target_smart_count < 3) then
    local targets = celi_wargreat.find_targets(smart)

    if (#targets > 0) then
      for i = 1, #targets do
        if not (smart.target_smarts[targets[i][2]]) then
          smart.target_smarts[targets[i][2]] = true
          break
        end
      end
    end
  end
end

function spawn_defense_squad(smart)
  if
    not (defense_timers[smart.id]) or
      (game.get_game_time():diffSec(defense_timers[smart.id]) > (defense_next_update[smart.id] * 60))
   then
    defense_timers[smart.id] = game.get_game_time()
    defense_next_update[smart.id] = sim_factions.faction_information[smart.owning_faction].respawn_defend
  else
    return
  end

  local faction = smart.owning_faction
  local npc_in_smart = npc_count_passive(smart, faction)

  local fi = sim_factions.faction_information[smart.owning_faction]

  if (fi) then
    if fi.faction_passive_npc_limit > fi.passive_npc then
      if npc_in_smart < smart.max_population then
        sim_squad.create_squad(smart, faction, nil, nil, nil, 1)
      end
    end
  end
end

function spawn_attack_squad(smart)
  if
    not (attack_timers[smart.id]) or
      (game.get_game_time():diffSec(attack_timers[smart.id]) > (attack_next_update[smart.id] * 60))
   then
    attack_timers[smart.id] = game.get_game_time()
    attack_next_update[smart.id] = sim_factions.faction_information[smart.owning_faction].respawn_attack
  else
    return
  end

  local night = (level.get_time_hours() < 6 or level.get_time_hours() > 20)
  local faction = smart.owning_faction

  if (night and math.random(100) > 80) then
    return
  end

  local s = {}
  for t, v in pairs(smart.target_smarts) do
    s[#s + 1] = t
  end

  local target

  for t, v in pairs(smart.target_smarts) do
    local other = alife():object(t)

    if other then
      if squad_count(other, smart.owning_faction) < 3 then
        target = other
      end
    end
  end

  if (target) then
    local need_spawn = npc_count_passive(target, target.owning_faction)

    if need_spawn > 10 then
      need_spawn = 10
    end

    local fi = sim_factions.faction_information[smart.owning_faction]

    if (fi) then
      local allowed_for_spawn = fi.faction_active_npc_limit - fi.active_npc

      if need_spawn > allowed_for_spawn then
        need_spawn = allowed_for_spawn
      end
    end

    sim_squad.create_squad(smart, faction, target, nil, need_spawn, 1)
  end
end

function spawn_mutants(smart)
  if
    not (mutant_timers[smart.id]) or
      (game.get_game_time():diffSec(mutant_timers[smart.id]) > (mutant_next_update[smart.id] * 60))
   then
    mutant_timers[smart.id] = game.get_game_time()
    mutant_next_update[smart.id] = 70
  else
    return
  end

  local mutants_on_level = sim_offline_control.get_num_squads_on_level(smart.level_id, "monster")
  local mutants = squad_count(smart, "monster")
  local mutant_coef = sim_brain.check_mutant_coef(smart)
  local level = alife():level_name(game_graph():vertex(smart.m_game_vertex_id):level_id())
  local section

  if level ~= l12u_control_monolith or level ~= l12u_sarcofag or level ~= l11_hospital then
    if (mutants_on_level < mutant_coef) then
      if mutants == 0 then
        local tier = sim_tables.mutants_tier_by_lvl

        if tier[level] ~= nil then
          section = tier[level][math.random(#tier[level])]
        end

        if section then
          sim_squad.create_squad(smart, nil, nil, section, nil, 1)
        end
      end
    end
  end
end

function process_mutants(smart)
  local tg = time_global()

  if smart.process_mutants ~= nil and tg < smart.process_mutants then
    return
  end

  smart.process_mutants = tg + 30000

  local squads = SIMBOARD.smarts[smart.id].squads
  local night = (level.get_time_hours() < 6 or level.get_time_hours() > 20)
  local level_info = sim_levels.level_information[smart.level_id]

  for id, squad in pairs(squads) do
    if squad:get_squad_community() == "monster" then
      for i, sm in pairs(level_info.smarts) do
        if (game.get_game_time():diffSec(squad.arrive_time) >= squad.wait_time) then
          local other = sm and alife():object(sm)
          if (other and other.props) then
            if (night) then
              if math.random(100) > 50 then
                if (other.owning_faction ~= "none") then
                  sim_squad.set_target(squad, sm)
                  break
                end
              else
                if (other.owning_faction == "none") then
                  local mutants_in_target = squad_count(other, "monster")

                  if mutants_in_target < 1 then
                    sim_squad.set_target(squad, sm)
                    break
                  end
                end
              end
            else
              if (other.owning_faction == "none") then
                local mutants_in_target = squad_count(other, "monster")

                if mutants_in_target < 1 then
                  sim_squad.set_target(squad, sm)
                  break
                end
              end
            end
          end
        end
      end
    end
  end
end

function smart_terrain.se_smart_terrain.show(self)
  if (hide_sim) then
    if (self.simulation_spot) then
      level.map_remove_object_spot(self.id, sim_tables.pda_icons[self.simulation_spot])
      self.simulation_spot = nil
    end
  else
    local faction = self.owning_faction
    local actor_faction = sim_brain.actor_faction
    local friends = game_relations.is_factions_friends(sim_brain.actor_faction, faction)
    local enemies = game_relations.is_factions_enemies(sim_brain.actor_faction, faction)

    if (self.simulation_spot) then
      if (self.simulation_spot ~= faction) then
        level.map_remove_object_spot(self.id, sim_tables.pda_icons[self.simulation_spot])
        level.map_add_object_spot(self.id, sim_tables.pda_icons[faction], get_simulation_info(self))
        self.simulation_spot = faction
      else
        level.map_change_spot_hint(self.id, sim_tables.pda_icons[faction], get_simulation_info(self))
      end
    else
      level.map_add_object_spot(self.id, sim_tables.pda_icons[faction], get_simulation_info(self))
      self.simulation_spot = faction
    end
  end
end

function smart_terrain.se_smart_terrain.hide(self)
  if (self.simulation_spot) then
    level.map_remove_object_spot(self.id, sim_tables.pda_icons[self.simulation_spot])
    self.simulation_spot = nil
  end
end

function get_simulation_info(smart)
  local sim_name = sim_script_to_text.smart_names[smart:name()]
  local npc_in_smart = npc_count(smart, smart.owning_faction)

  local props = ""
  local type = ""

  if (sim_name) then
    props = "\\n" .. sim_name .. "\\n"
  else
    props = "\\n" .. smart:name() .. "\\n"
  end

  if (smart.props) then
    if (smart.props.base > 0) then
      type = "Áàçà"
    elseif (smart.props.resource > 0) then
      type = "Òî÷êà ðåñóðñîâ"
    elseif (smart.props.territory > 0) then
      type = "Òåððèòîðèÿ"
    elseif (smart.props.lair > 0) then
      type = "Ëîãîâî"
    end
  end

  if smart.owning_faction == "none" then
    props = props .. "\\n" .. type .. "\\n"
  else
    props =
      props ..
      "\\n" .. type .. ", ïîä êîíòðîëåì ãðóïïèðîâêè " .. game.translate_string(smart.owning_faction) .. "\\n"

    if npc_in_smart <= 3 then
      props = props .. "\\nÍèçêàÿ óêðåïëåííîñòü \\n"
    elseif npc_in_smart > 3 and npc_in_smart <= 7 then
      props = props .. "\\nÑðåäíÿÿ óêðåïëåííîñòü \\n"
    elseif npc_in_smart > 7 then
      props = props .. "\\nÂûñîêàÿ óêðåïëåííîñòü \\n"
    end
  end

  if (smart.owning_faction) then
  end

  local f = false
  smart.target_smarts = smart.target_smarts or {}
  for target, _ in pairs(smart.target_smarts) do
    if not (f) then
      f = true
      props = props .. "\\nÖåëè:\\n"
    end

    local other = alife():object(target)

    if (other) then
      local otherGreatWar = sim_script_to_text.smart_names[other:name()] or other:name()
      props = props .. "\\n" .. otherGreatWar .. "\\n"
    end
  end

  if smart.props.base > 0 and attack_next_update[smart.id] ~= nil and attack_timers[smart.id] ~= nil then
    props =
      props ..
      "\\n\\nÀòàêóþùèé îòðÿä áóäåò ãîòîâ ÷åðåç: " ..
        ((attack_next_update[smart.id] * 60) - (game.get_game_time():diffSec(attack_timers[smart.id]))) / 60
  end

  if smart.props.base > 0 and defense_next_update[smart.id] ~= nil and defense_timers[smart.id] ~= nil then
    props =
      props ..
      "\\n\\nÇàùèòíûé îòðÿä áóäåò ãîòîâ ÷åðåç: " ..
        ((defense_next_update[smart.id] * 60) - (game.get_game_time():diffSec(defense_timers[smart.id]))) / 60
  end

  if smart.props.lair > 0 and mutant_next_update[smart.id] ~= nil and mutant_timers[smart.id] ~= nil then
    props =
      props ..
      "\\n\\nÌóòàíòû ïðèéäóò ÷åðåç: " ..
        ((mutant_next_update[smart.id] * 60) - (game.get_game_time():diffSec(mutant_timers[smart.id]))) / 60
  end

  return props
end

function squad_count(smart, faction)
  if not (smart.owning_faction) then
    smart.owning_faction = "none"
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local squad_count = 0

  for i, squad in pairs(squads) do
    if (squad.registered_in_simultaion and squad:get_squad_community() == faction) then
      squad_count = squad_count + 1
    end
  end

  return squad_count
end

function npc_count(smart, faction)
  if not (smart.owning_faction) then
    smart.owning_faction = "none"
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local npc_count = 0

  for i, squad in pairs(squads) do
    if (squad.registered_in_simultaion and squad:get_squad_community() == faction) then
      local npc_in_squad = squad:npc_count()
      npc_count = npc_count + npc_in_squad
    end
  end

  return npc_count
end

function npc_count_passive(smart, faction)
  if not (smart.owning_faction) then
    smart.owning_faction = "none"
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local npc_count = 0

  for i, squad in pairs(squads) do
    if (squad.registered_in_simultaion and squad:get_squad_community() == faction and squad.current_action == 1) then
      local npc_in_squad = squad:npc_count()
      npc_count = npc_count + npc_in_squad
    end
  end

  return npc_count
end

function npc_count_active(smart, faction)
  if not (smart.owning_faction) then
    smart.owning_faction = "none"
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local npc_count = 0

  for i, squad in pairs(squads) do
    if (squad.registered_in_simultaion and squad:get_squad_community() == faction and squad.current_action == 0) then
      local npc_in_squad = squad:npc_count()
      npc_count = npc_count + npc_in_squad
    end
  end

  return npc_count
end

function check_owner(smart)
  if not (smart) then
    return
  end

  if (smart.time_to_capture) then
    smart.owning_faction = "none"
    return
  end

  if (not SIMBOARD.smarts[smart.id]) then
    smart.owning_faction = "none"
    return
  end

  if not (SIMBOARD.smarts[smart.id].squads) then
    smart.owning_faction = "none"
    return
  end

  local squads = SIMBOARD.smarts[smart.id].squads
  local squadCount = {}
  local squadPowers = {}

  if not (smart.owning_faction) then
    smart.owning_faction = "none"
  end

  for i, squad in pairs(squads) do
    if ((squad.current_action == 1 or squad.combat_action == 1) and squad.registered_in_simultaion) then
      local faction = squad:get_squad_community()

      if not (squadCount[faction]) then
        squadCount[faction] = 0
        squadPowers[faction] = 0
      end

      local power = sim_offline_control.ocs_power_table[squad.id]

      if (power and power > 0) then
        squadPowers[faction] = squadPowers[faction] + power
      end

      squadCount[faction] = squadCount[faction] + 1
    end
  end

  local owner = "none"
  for faction, count in pairs(squadCount) do
    if (owner == "none" or faction == smart.owning_faction) then
      owner = faction
    elseif (squadCount[owner] < count and smart.owning_faction == "none") then
      owner = faction
    end
  end

  if (owner == "monster") then
    owner = "none"
  end

  smart.defense_count = squadCount[owner] or 0
  smart.defense_power = squadPowers[owner] or 0

  if not (smart.last_owner) then
    smart.last_owner = owner
  end

  if (smart.last_owner ~= smart.owning_faction) then
    sim_offline_to_online.switch_control_news(smart)
    if (smart.target_smarts) then
      smart:hide()
      smart.target_smarts = {}
      smart:show()
    end
  end

  if (smart.last_owner) then
    smart.last_owner = smart.owning_faction
  end

  smart.owning_faction = owner
end
